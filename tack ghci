[1mdiff --git a/src/Combinators.hs b/src/Combinators.hs[m
[1mindex eb3b18f..20d9fa3 100644[m
[1m--- a/src/Combinators.hs[m
[1m+++ b/src/Combinators.hs[m
[36m@@ -8,9 +8,15 @@[m [mimport           Data.List           (nub, sortBy)[m
 data Result error input result[m
   = Success (InputStream input) result[m
   | Failure [ErrorMsg error][m
[31m-  deriving (Eq)[m
 [m
[31m-type Position = Int[m
[32m+[m
[32m+[m[32mdata Position = Position { line :: Int, col :: Int }[m
[32m+[m[32m              deriving (Show, Eq)[m
[32m+[m
[32m+[m[32minstance Ord Position where[m
[32m+[m[32m  (Position a b) < (Position a' b') = if a == a' then b < b' else a < a'[m
[32m+[m[32m  a <= a' = a < a' || a == a'[m
[32m+[m
 [m
 newtype Parser error input result[m
   = Parser { runParser' :: (InputStream input) -> Result error input result }[m
[36m@@ -19,11 +25,10 @@[m [mdata InputStream a = InputStream { stream :: a, curPos :: Position }[m
                    deriving (Show, Eq)[m
 [m
 data ErrorMsg e = ErrorMsg { errors :: [e], pos :: Position }[m
[31m-                deriving (Eq)[m
 [m
 makeError e p = ErrorMsg [e] p[m
 [m
[31m-initPosition = 0[m
[32m+[m[32minitPosition = Position 0 0[m
 [m
 runParser :: Parser error input result -> input -> Result error input result[m
 runParser parser input = runParser' parser (InputStream input initPosition)[m
[36m@@ -31,8 +36,10 @@[m [mrunParser parser input = runParser' parser (InputStream input initPosition)[m
 toStream :: a -> Position -> InputStream a[m
 toStream = InputStream[m
 [m
[31m-incrPos :: InputStream a -> InputStream a[m
[31m-incrPos (InputStream str pos) = InputStream str (pos + 1)[m
[32m+[m[32mincrPos :: Position -> Char -> Position[m
[32m+[m[32mincrPos (Position line col) '\t' = Position line (col + 4)[m
[32m+[m[32mincrPos (Position line col) '\n' = Position (line + 1) 0[m
[32m+[m[32mincrPos (Position line col) _ = Position line (col + 1)[m
 [m
 instance Functor (Parser error input) where[m
   fmap f (Parser runp) = Parser $ \inp ->[m
[36m@@ -94,15 +101,12 @@[m [meof :: Parser String String ()[m
 eof = Parser $ \input -> if null $ stream input then Success input () else Failure [makeError "Not eof" (curPos input)][m
 [m
 -- –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç –ø—Ä–µ–¥–∏–∫–∞—Ç—É[m
[31m-satisfy :: (a -> Bool) -> Parser String [a] a[m
[32m+[m[32msatisfy :: (Char -> Bool) -> Parser String String Char[m
 satisfy p = Parser $ \(InputStream input pos) ->[m
   case input of[m
[31m-    (x:xs) | p x -> Success (incrPos $ InputStream xs pos) x[m
[32m+[m[32m    (x:xs) | p x -> Success (InputStream xs (incrPos pos x)) x[m
     input        -> Failure [makeError "Predicate failed" pos][m
 [m
[31m-parseStr :: String -> Parser String String String[m
[31m-parseStr = foldr (\x acc -> (:) <$> symbol x <*> acc) (pure "")[m
[31m-[m
 -- –£—Å–ø–µ—à–Ω–æ –ø–∞—Ä—Å–∏—Ç –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É[m
 epsilon :: Parser e i ()[m
 epsilon = success ()[m
[36m@@ -122,12 +126,21 @@[m [mword :: String -> Parser String String String[m
 word w = Parser $ \(InputStream input pos) ->[m
   let (pref, suff) = splitAt (length w) input in[m
   if pref == w[m
[31m-  then Success (InputStream suff (pos + length w)) w[m
[32m+[m[32m  then Success (InputStream suff (foldl incrPos pos w)) w[m
   else Failure [makeError ("Expected " ++ show w) pos][m
 [m
[32m+[m[32mparseStr :: String -> Parser String String String[m
[32m+[m[32mparseStr = word[m
[32m+[m
 instance Show (ErrorMsg String) where[m
   show (ErrorMsg e pos) = "at position " ++ show pos ++ ":\n" ++ (unlines $ map ('\t':) (nub e))[m
 [m
 instance (Show input, Show result) => Show (Result String input result) where[m
   show (Failure e) = "Parsing failed\n" ++ unlines (map show e)[m
   show (Success i r) = "Parsing succeeded!\nResult:\n" ++ show r ++ "\nSuffix:\t" ++ show i[m
[32m+[m
[32m+[m[32minstance Eq (ErrorMsg String) where[m
[32m+[m[32m  e1 == e2 = (show e1) == (show e2)[m
[32m+[m
[32m+[m[32minstance (Show input, Show result) => Eq (Result String input result) where[m
[32m+[m[32m  e1 == e2 = (show e1) == (show e2)[m
[1mdiff --git a/src/Expr.hs b/src/Expr.hs[m
[1mindex 4ead691..0d146d7 100644[m
[1m--- a/src/Expr.hs[m
[1m+++ b/src/Expr.hs[m
[36m@@ -3,7 +3,7 @@[m [mmodule Expr where[m
 import           AST                 (AST (..), Operator (..), Subst (..))[m
 import           Combinators         (Parser (..), Result (..), fail',[m
                                       runParser, satisfy, stream, success,[m
[31m-                                      symbol, parseStr, manyWithSep)[m
[32m+[m[32m                                      symbol, parseStr, manyWithSep, (<?>))[m
 import           Control.Applicative[m
 import           Data.Char           (digitToInt, isDigit, isLetter)[m
 import qualified Data.Map            as Map[m
[36m@@ -83,7 +83,7 @@[m [mparseSep = many (symbol ' ' <|> symbol '\n' <|> symbol '\t')[m
 -- —Å –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏ –∏ –∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å—é –Ω–∞–¥ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏ —Å 0.[m
 -- –í —Å—Ç—Ä–æ–∫–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–∫–æ–±–∫–∏[m
 parseExpr :: Parser String String AST[m
[31m-parseExpr = uberExpr [(or', Binary RightAssoc),[m
[32m+[m[32mparseExpr = "Expected expression" <?> uberExpr [(or', Binary RightAssoc),[m
                       (and', Binary RightAssoc),[m
                       (not', Unary),[m
                       (equal <|> nequal <|> ge <|> gt <|> le <|> lt, Binary NoAssoc),[m
[36m@@ -99,7 +99,7 @@[m [mparseExpr = uberExpr [(or', Binary RightAssoc),[m
 [m
 -- –ü–∞—Ä—Å–µ—Ä –¥–ª—è —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª[m
 parseNum :: Parser String String Int[m
[31m-parseNum = parseSep *> (foldl (\acc d -> 10 * acc + digitToInt d) 0 <$> go) <* parseSep[m
[32m+[m[32mparseNum = "Expected number" <?> parseSep *> (foldl (\acc d -> 10 * acc + digitToInt d) 0 <$> go) <* parseSep[m
   where[m
     go :: Parser String String String[m
     go = some (satisfy isDigit)[m
[36m@@ -107,7 +107,7 @@[m [mparseNum = parseSep *> (foldl (\acc d -> 10 * acc + digitToInt d) 0 <$> go) <* p[m
 parseIdent :: Parser String String String[m
 parseIdent = let id = (:) <$> (satisfy isLetter <|> symbol '_') <*>[m
                       many (satisfy isLetter <|> symbol '_' <|> satisfy isDigit) in[m
[31m-             parseSep *> id <* parseSep[m
[32m+[m[32m             "Expected identifier" <?> parseSep *> id <* parseSep[m
 [m
 evaluate :: String -> Maybe Int[m
 evaluate input = do[m
[1mdiff --git a/test/Test/Combinators.hs b/test/Test/Combinators.hs[m
[1mindex acb8ce9..5348f94 100644[m
[1m--- a/test/Test/Combinators.hs[m
[1m+++ b/test/Test/Combinators.hs[m
[36m@@ -2,7 +2,7 @@[m [mmodule Test.Combinators where[m
 [m
 import           Combinators         (Parser, Result (..), runParser,[m
                                       runParser, satisfy, symbol,[m
[31m-                                      toStream)[m
[32m+[m[32m                                      toStream, Position (..))[m
 import           Control.Applicative[m
 import           Test.Tasty.HUnit    (Assertion, assertBool, (@?=))[m
 [m
[36m@@ -17,20 +17,20 @@[m [mdigit = satisfy (`elem` "0123456789")[m
 unit_satisfy :: Assertion[m
 unit_satisfy = do[m
     testFailure $ runParser (satisfy (/= '1')) "1234"[m
[31m-    runParser (satisfy (== '1')) "1234" @?= Success (toStream "234" 1) '1'[m
[31m-    runParser digit "1234" @?= Success (toStream "234" 1) '1'[m
[32m+[m[32m    runParser (satisfy (== '1')) "1234" @?= Success (toStream "234" (Position 0 1)) '1'[m
[32m+[m[32m    runParser digit "1234" @?= Success (toStream "234" (Position 0 1)) '1'[m
     testFailure $ runParser digit "blah"[m
 [m
 unit_many :: Assertion[m
 unit_many = do[m
[31m-    runParser (many $ symbol '1') "234" @?= Success (toStream "234" 0) ""[m
[31m-    runParser (many $ symbol '1') "134" @?= Success (toStream "34" 1) "1"[m
[31m-    runParser (many $ symbol '1') "114" @?= Success (toStream "4" 2) "11"[m
[31m-    runParser (many $ symbol '1') "111" @?= Success (toStream "" 3)"111"[m
[32m+[m[32m    runParser (many $ symbol '1') "234" @?= Success (toStream "234" (Position 0 0)) ""[m
[32m+[m[32m    runParser (many $ symbol '1') "134" @?= Success (toStream "34" (Position 0 1)) "1"[m
[32m+[m[32m    runParser (many $ symbol '1') "114" @?= Success (toStream "4" (Position 0 2)) "11"[m
[32m+[m[32m    runParser (many $ symbol '1') "111" @?= Success (toStream "" (Position 0 3))"111"[m
 [m
 unit_some :: Assertion[m
 unit_some = do[m
     testFailure $ runParser (some $ symbol '1') "234"[m
[31m-    runParser (some $ symbol '1') "134" @?= Success (toStream "34" 1) "1"[m
[31m-    runParser (some $ symbol '1') "114" @?= Success (toStream "4" 2) "11"[m
[31m-    runParser (some $ symbol '1') "111" @?= Success (toStream "" 3)"111"[m
[32m+[m[32m    runParser (some $ symbol '1') "134" @?= Success (toStream "34" (Position 0 1)) "1"[m
[32m+[m[32m    runParser (some $ symbol '1') "114" @?= Success (toStream "4" (Position 0 2)) "11"[m
[32m+[m[32m    runParser (some $ symbol '1') "111" @?= Success (toStream "" (Position 0 3))"111"[m
[1mdiff --git a/test/Test/Expr.hs b/test/Test/Expr.hs[m
[1mindex dd2d926..6b62b68 100644[m
[1m--- a/test/Test/Expr.hs[m
[1m+++ b/test/Test/Expr.hs[m
[36m@@ -3,7 +3,8 @@[m [mmodule Test.Expr where[m
 import           AST                 (AST (..), Operator (..))[m
 import           Combinators         (InputStream (..), Parser (..),[m
                                       Result (..), runParser,[m
[31m-                                      symbol, toStream, word)[m
[32m+[m[32m                                      symbol, toStream, word,[m
[32m+[m[32m                                      Position (..))[m
 import           Control.Applicative ((<|>))[m
 import           Expr                (Associativity (..), OpType (..), evaluate,[m
                                       parseExpr, parseNum,                                       uberExpr, parseIdent)[m
[36m@@ -36,78 +37,79 @@[m [munit_evaluate = do[m
 [m
 unit_parseNum :: Assertion[m
 unit_parseNum = do[m
[31m-    runParser parseNum "7" @?= Success (toStream "" 1) (7)[m
[31m-    runParser parseNum "12+3" @?= Success (toStream "+3" 2) (12)[m
[31m-    runParser parseNum "007" @?= Success (toStream "" 3) (7)[m
[31m-    runParser parseNum " 007 " @?= Success (toStream "" 5) (7)[m
[32m+[m[32m    runParser parseNum "7" @?= Success (toStream "" (Position 0 1)) (7)[m
[32m+[m[32m    runParser parseNum "12+3" @?= Success (toStream "+3" (Position 0 2)) (12)[m
[32m+[m[32m    runParser parseNum "007" @?= Success (toStream "" (Position 0 3)) (7)[m
[32m+[m[32m    runParser parseNum " 007 " @?= Success (toStream "" (Position 0 5)) (7)[m
     testFailure (runParser parseNum "+3")[m
     testFailure (runParser parseNum "a")[m
 [m
 unit_parseIdent :: Assertion[m
 unit_parseIdent = do[m
[31m-    runParser parseIdent "abc def" @?= Success (toStream "def" 4) "abc"[m
[31m-    runParser parseIdent "AbC dEf" @?= Success (toStream "dEf" 4) "AbC"[m
[31m-    runParser parseIdent "_123" @?= Success (toStream "" 4) "_123"[m
[31m-    runParser parseIdent "a_b_c d_e" @?= Success (toStream "d_e" 6) "a_b_c"[m
[31m-    runParser parseIdent " a_b_c d_e" @?= Success (toStream "d_e" 7) "a_b_c"[m
[31m-    runParser parseIdent "x_" @?= Success (toStream "" 2) "x_"[m
[31m-    runParser parseIdent "abc123" @?= Success (toStream "" 6) "abc123"[m
[31m-    runParser parseIdent "_" @?= Success (toStream "" 1) "_"[m
[31m-    runParser parseIdent "abc*1" @?= Success (toStream "*1" 3) "abc"[m
[32m+[m[32m    runParser parseIdent "abc def" @?= Success (toStream "def" (Position 0 4)) "abc"[m
[32m+[m[32m    runParser parseIdent "AbC dEf" @?= Success (toStream "dEf" (Position 0 4)) "AbC"[m
[32m+[m[32m    runParser parseIdent "_123" @?= Success (toStream "" (Position 0 4)) "_123"[m
[32m+[m[32m    runParser parseIdent "a_b_c d_e" @?= Success (toStream "d_e" (Position 0 6)) "a_b_c"[m
[32m+[m[32m    runParser parseIdent " a_b_c d_e" @?= Success (toStream "d_e" (Position 0 7)) "a_b_c"[m
[32m+[m[32m    runParser parseIdent "x_" @?= Success (toStream "" (Position 0 2)) "x_"[m
[32m+[m[32m    runParser parseIdent "abc123" @?= Success (toStream "" (Position 0 6)) "abc123"[m
[32m+[m[32m    runParser parseIdent "_" @?= Success (toStream "" (Position 0 1)) "_"[m
[32m+[m[32m    runParser parseIdent "abc*1" @?= Success (toStream "*1" (Position 0 3)) "abc"[m
     testFailure $ runParser parseIdent "123abc"[m
     testFailure $ runParser parseIdent "123"[m
     testFailure $ runParser parseIdent ""[m
 [m
 erasePosition :: Result e i a -> Result e i a[m
[31m-erasePosition (Success str x) = Success (InputStream (stream str) 0) x[m
[32m+[m[32merasePosition (Success str x) = Success (InputStream (stream str) (Position 0 0)) x[m
 erasePosition x               = x[m
 [m
 unit_parseExpr :: Assertion[m
 unit_parseExpr = do[m
[31m-    runParser parseExpr "1*2*3"   @?= Success (toStream "" 5) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[31m-    runParser parseExpr "123"     @?= Success (toStream "" 3) (Num 123)[m
[31m-    runParser parseExpr "abc"     @?= Success (toStream "" 3) (Ident "abc")[m
[31m-    runParser parseExpr "1*2+3*4" @?= Success (toStream "" 7) (BinOp Plus (BinOp Mult (Num 1) (Num 2)) (BinOp Mult (Num 3) (Num 4)))[m
[31m-    runParser parseExpr "1+2*3+4" @?= Success (toStream "" 7) (BinOp Plus (BinOp Plus (Num 1) (BinOp Mult (Num 2) (Num 3))) (Num 4))[m
[31m-    runParser parseExpr "1*x*3"   @?= Success (toStream "" 5) (BinOp Mult (BinOp Mult (Num 1) (Ident "x")) (Num 3))[m
[31m-    runParser parseExpr "xyz"     @?= Success (toStream "" 3) (Ident "xyz")[m
[31m-    runParser parseExpr "1*x+z*4" @?= Success (toStream "" 7) (BinOp Plus (BinOp Mult (Num 1) (Ident "x")) (BinOp Mult (Ident "z") (Num 4)))[m
[31m-    runParser parseExpr "1+y*3+z" @?= Success (toStream "" 7) (BinOp Plus (BinOp Plus (Num 1) (BinOp Mult (Ident "y") (Num 3))) (Ident "z"))[m
[31m-    runParser parseExpr "1+x" @?= Success (toStream "" 3) (BinOp Plus (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1-x" @?= Success (toStream "" 3) (BinOp Minus (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1*x" @?= Success (toStream "" 3) (BinOp Mult (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1/x" @?= Success (toStream "" 3) (BinOp Div (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1^x" @?= Success (toStream "" 3) (BinOp Pow (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1==x" @?= Success (toStream "" 4)  (BinOp Equal (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1/=x" @?= Success (toStream "" 4)  (BinOp Nequal (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1>x" @?= Success (toStream "" 3) (BinOp Gt (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1>=x" @?= Success (toStream "" 4)  (BinOp Ge (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1<x" @?= Success (toStream "" 3) (BinOp Lt (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1<=x" @?= Success (toStream "" 4)  (BinOp Le (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1&&x" @?= Success (toStream "" 4)  (BinOp And (Num 1) (Ident "x"))[m
[31m-    runParser parseExpr "1||x" @?= Success (toStream "" 4)  (BinOp Or (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1*2*3"   @?= Success (toStream "" (Position 0 5)) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m    runParser parseExpr "123"     @?= Success (toStream "" (Position 0 3)) (Num 123)[m
[32m+[m[32m    runParser parseExpr "abc"     @?= Success (toStream "" (Position 0 3)) (Ident "abc")[m
[32m+[m[32m    runParser parseExpr "1*2+3*4" @?= Success (toStream "" (Position 0 7)) (BinOp Plus (BinOp Mult (Num 1) (Num 2)) (BinOp Mult (Num 3) (Num 4)))[m
[32m+[m[32m    runParser parseExpr "1+2*3+4" @?= Success (toStream "" (Position 0 7)) (BinOp Plus (BinOp Plus (Num 1) (BinOp Mult (Num 2) (Num 3))) (Num 4))[m
[32m+[m[32m    runParser parseExpr "1*x*3"   @?= Success (toStream "" (Position 0 5)) (BinOp Mult (BinOp Mult (Num 1) (Ident "x")) (Num 3))[m
[32m+[m[32m    runParser parseExpr "xyz"     @?= Success (toStream "" (Position 0 3)) (Ident "xyz")[m
[32m+[m[32m    runParser parseExpr "1*x+z*4" @?= Success (toStream "" (Position 0 7)) (BinOp Plus (BinOp Mult (Num 1) (Ident "x")) (BinOp Mult (Ident "z") (Num 4)))[m
[32m+[m[32m    runParser parseExpr "1+y*3+z" @?= Success (toStream "" (Position 0 7)) (BinOp Plus (BinOp Plus (Num 1) (BinOp Mult (Ident "y") (Num 3))) (Ident "z"))[m
[32m+[m[32m    runParser parseExpr "1+x" @?= Success (toStream "" (Position 0 3)) (BinOp Plus (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1-x" @?= Success (toStream "" (Position 0 3)) (BinOp Minus (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1*x" @?= Success (toStream "" (Position 0 3)) (BinOp Mult (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1/x" @?= Success (toStream "" (Position 0 3)) (BinOp Div (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1^x" @?= Success (toStream "" (Position 0 3)) (BinOp Pow (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1==x" @?= Success (toStream "" (Position 0 4))  (BinOp Equal (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1/=x" @?= Success (toStream "" (Position 0 4))  (BinOp Nequal (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1>x" @?= Success (toStream "" (Position 0 3)) (BinOp Gt (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1>=x" @?= Success (toStream "" (Position 0 4))  (BinOp Ge (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1<x" @?= Success (toStream "" (Position 0 3)) (BinOp Lt (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1<=x" @?= Success (toStream "" (Position 0 4))  (BinOp Le (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1&&x" @?= Success (toStream "" (Position 0 4))  (BinOp And (Num 1) (Ident "x"))[m
[32m+[m[32m    runParser parseExpr "1||x" @?= Success (toStream "" (Position 0 4))  (BinOp Or (Num 1) (Ident "x"))[m
     (erasePosition $ runParser parseExpr "(1==x+2)||3*4<y-5/6&&(7/=z^8)||(id>12)&&abc<=13||xyz>=42") @?=[m
       (erasePosition $ runParser parseExpr "(1==(x+2))||(((3*4)<(y-(5/6))&&(7/=(z^8)))||(((id>12)&&(abc<=13))||(xyz>=42)))")[m
 [m
[31m-    runParser parseExpr "-1+2" @?= Success (toStream "" 4) (BinOp Plus (UnaryOp Minus (Num 1)) (Num 2))[m
[31m-    runParser parseExpr "-1*2" @?= Success (toStream "" 4) (BinOp Mult (UnaryOp Minus (Num 1)) (Num 2))[m
[31m-    runParser parseExpr "-1==2" @?= Success (toStream "" 5) (BinOp Equal (UnaryOp Minus (Num 1)) (Num 2))[m
[31m-    runParser parseExpr "-1==-2" @?= Success (toStream "" 6) (BinOp Equal (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[31m-    runParser parseExpr "-1&&-2" @?= Success (toStream "" 6) (BinOp And (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[31m-    runParser parseExpr "!1&&!2" @?= Success (toStream "" 6) (BinOp And (UnaryOp Not (Num 1)) (UnaryOp Not (Num 2)))[m
[31m-    runParser parseExpr "-1^2" @?= Success (toStream "" 4) (UnaryOp Minus (BinOp Pow (Num 1) (Num 2)))[m
[31m-    runParser parseExpr "-1^(-2)" @?= Success (toStream "" 7) (UnaryOp Minus (BinOp Pow (Num 1) (UnaryOp Minus (Num 2))))[m
[31m-    runParser parseExpr "(-1)^2" @?= Success (toStream "" 6) (BinOp Pow (UnaryOp Minus (Num 1)) (Num 2))[m
[31m-    runParser parseExpr "-1+-2" @?= Success (toStream "" 5) (BinOp Plus (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[31m-    runParser parseExpr "!-1" @?= Success (toStream "" 3) (UnaryOp Not (UnaryOp Minus (Num 1)))[m
[31m-    runParser parseExpr "!(-1)" @?= Success (toStream "" 5) (UnaryOp Not (UnaryOp Minus (Num 1)))[m
[31m-    runParser parseExpr "-(!1)" @?= Success (toStream "" 5) (UnaryOp Minus (UnaryOp Not (Num 1)))[m
[31m-    runParser parseExpr "-1---2" @?= Success (toStream "---2" 2) (UnaryOp Minus (Num 1))[m
[31m-    runParser parseExpr "-1^-2" @?= Success (toStream "^-2" 2) (UnaryOp Minus (Num 1))[m
[31m-[m
[31m-    runParser parseExpr "f(2, 3)" @?= Success (toStream "" 7) (FunctionCall "f" [Num 2, Num 3])[m
[31m-    runParser parseExpr " f ( 2,3 ) " @?= Success (toStream "" 11) (FunctionCall "f" [Num 2, Num 3])[m
[31m-    runParser parseExpr " f ( \n ) " @?= Success (toStream "" 9) (FunctionCall "f" [])[m
[32m+[m[32m    runParser parseExpr "-1+2" @?= Success (toStream "" (Position 0 4)) (BinOp Plus (UnaryOp Minus (Num 1)) (Num 2))[m
[32m+[m[32m    runParser parseExpr "-1*2" @?= Success (toStream "" (Position 0 4)) (BinOp Mult (UnaryOp Minus (Num 1)) (Num 2))[m
[32m+[m[32m    runParser parseExpr "-1==2" @?= Success (toStream "" (Position 0 5)) (BinOp Equal (UnaryOp Minus (Num 1)) (Num 2))[m
[32m+[m[32m    runParser parseExpr "-1==-2" @?= Success (toStream "" (Position 0 6)) (BinOp Equal (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[32m+[m[32m    runParser parseExpr "-1&&-2" @?= Success (toStream "" (Position 0 6)) (BinOp And (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[32m+[m[32m    runParser parseExpr "!1&&!2" @?= Success (toStream "" (Position 0 6)) (BinOp And (UnaryOp Not (Num 1)) (UnaryOp Not (Num 2)))[m
[32m+[m[32m    runParser parseExpr "-1^2" @?= Success (toStream "" (Position 0 4)) (UnaryOp Minus (BinOp Pow (Num 1) (Num 2)))[m
[32m+[m[32m    runParser parseExpr "-1^(-2)" @?= Success (toStream "" (Position 0 7)) (UnaryOp Minus (BinOp Pow (Num 1) (UnaryOp Minus (Num 2))))[m
[32m+[m[32m    runParser parseExpr "(-1)^2" @?= Success (toStream "" (Position 0 6)) (BinOp Pow (UnaryOp Minus (Num 1)) (Num 2))[m
[32m+[m[32m    runParser parseExpr "-1+-2" @?= Success (toStream "" (Position 0 5)) (BinOp Plus (UnaryOp Minus (Num 1)) (UnaryOp Minus (Num 2)))[m
[32m+[m[32m    runParser parseExpr "!-1" @?= Success (toStream "" (Position 0 3)) (UnaryOp Not (UnaryOp Minus (Num 1)))[m
[32m+[m[32m    runParser parseExpr "!(-1)" @?= Success (toStream "" (Position 0 5)) (UnaryOp Not (UnaryOp Minus (Num 1)))[m
[32m+[m[32m    runParser parseExpr "-(!1)" @?= Success (toStream "" (Position 0 5)) (UnaryOp Minus (UnaryOp Not (Num 1)))[m
[32m+[m[32m    runParser parseExpr "-1---2" @?= Success (toStream "---2" (Position 0 2)) (UnaryOp Minus (Num 1))[m
[32m+[m[32m    runParser parseExpr "-1^-2" @?= Success (toStream "^-2" (Position 0 2)) (UnaryOp Minus (Num 1))[m
[32m+[m
[32m+[m[32m    runParser parseExpr "f(2, 3)" @?= Success (toStream "" (Position 0 7)) (FunctionCall "f" [Num 2, Num 3])[m
[32m+[m[32m    runParser parseExpr " f ( 2,3 ) " @?= Success (toStream "" (Position 0 11)) (FunctionCall "f" [Num 2, Num 3])[m
[32m+[m[32m    runParser parseExpr " f ( \n ) " @?= Success (toStream "" (Position 1 3)) (FunctionCall "f" [])[m
[32m+[m[32m    runParser parseExpr " f ( \n )\t" @?= Success (toStream "" (Position 1 6)) (FunctionCall "f" [])[m
 [m
     testFailure $ runParser parseExpr "--1"[m
     testFailure $ runParser parseExpr "-!1"[m
[36m@@ -137,22 +139,22 @@[m [mexpr2 =[m
 [m
 unit_expr1 :: Assertion[m
 unit_expr1 = do[m
[31m-  runParser expr1 "13" @?= Success (toStream "" 2) (Num 13)[m
[31m-  runParser expr1 "(((1)))" @?= Success (toStream "" 7) (Num 1)[m
[31m-  runParser expr1 "1+2*3-4/5" @?= Success (toStream "" 9) (BinOp Mult (BinOp Plus (Num 1) (Num 2)) (BinOp Minus (Num 3) (BinOp Div (Num 4) (Num 5))))[m
[31m-  runParser expr1 "1+2+3" @?= Success (toStream "+3" 3) (BinOp Plus (Num 1) (Num 2))[m
[31m-  runParser expr1 "1*2*3" @?= Success (toStream "" 5) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[31m-  runParser expr1 "1/2/3" @?= Success (toStream "" 5) (BinOp Div (Num 1) (BinOp Div (Num 2) (Num 3)))[m
[31m-  runParser expr1 "1-2-3" @?= Success (toStream "" 5) (BinOp Minus (Num 1) (BinOp Minus (Num 2) (Num 3)))[m
[31m-  runParser expr1 "1-2*3/4+5*6-7-8/9" @?= Success (toStream "" 17) (BinOp Mult (BinOp Mult (BinOp Minus (Num 1) (Num 2)) (BinOp Div (Num 3) (BinOp Plus (Num 4) (Num 5)))) (BinOp Minus (Num 6) (BinOp Minus (Num 7) (BinOp Div (Num 8) (Num 9)))))[m
[32m+[m[32m  runParser expr1 "13" @?= Success (toStream "" (Position 0 2)) (Num 13)[m
[32m+[m[32m  runParser expr1 "(((1)))" @?= Success (toStream "" (Position 0 7)) (Num 1)[m
[32m+[m[32m  runParser expr1 "1+2*3-4/5" @?= Success (toStream "" (Position 0 9)) (BinOp Mult (BinOp Plus (Num 1) (Num 2)) (BinOp Minus (Num 3) (BinOp Div (Num 4) (Num 5))))[m
[32m+[m[32m  runParser expr1 "1+2+3" @?= Success (toStream "+3" (Position 0 3)) (BinOp Plus (Num 1) (Num 2))[m
[32m+[m[32m  runParser expr1 "1*2*3" @?= Success (toStream "" (Position 0 5)) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m  runParser expr1 "1/2/3" @?= Success (toStream "" (Position 0 5)) (BinOp Div (Num 1) (BinOp Div (Num 2) (Num 3)))[m
[32m+[m[32m  runParser expr1 "1-2-3" @?= Success (toStream "" (Position 0 5)) (BinOp Minus (Num 1) (BinOp Minus (Num 2) (Num 3)))[m
[32m+[m[32m  runParser expr1 "1-2*3/4+5*6-7-8/9" @?= Success (toStream "" (Position 0 17)) (BinOp Mult (BinOp Mult (BinOp Minus (Num 1) (Num 2)) (BinOp Div (Num 3) (BinOp Plus (Num 4) (Num 5)))) (BinOp Minus (Num 6) (BinOp Minus (Num 7) (BinOp Div (Num 8) (Num 9)))))[m
 [m
 unit_expr2 :: Assertion[m
 unit_expr2 = do[m
[31m-  runParser expr2 "13" @?= Success (toStream "" 2) (Num 13)[m
[32m+[m[32m  runParser expr2 "13" @?= Success (toStream "" (Position 0 2)) (Num 13)[m
   testFailure $ runParser expr2 "(((1)))"[m
[31m-  runParser expr2 "1+2*3-4/5" @?= Success (toStream "" 9) (BinOp Div (BinOp Minus (BinOp Mult (BinOp Plus (Num 1) (Num 2)) (Num 3)) (Num 4)) (Num 5))[m
[31m-  runParser expr2 "1+2+3" @?= Success (toStream "" 5) (BinOp Plus (BinOp Plus (Num 1) (Num 2)) (Num 3))[m
[31m-  runParser expr2 "1*2*3" @?= Success (toStream "" 5) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[31m-  runParser expr2 "1/2/3" @?= Success (toStream "" 5) (BinOp Div (BinOp Div (Num 1) (Num 2)) (Num 3))[m
[31m-  runParser expr2 "1-2-3" @?= Success (toStream "" 5) (BinOp Minus (BinOp Minus (Num 1) (Num 2)) (Num 3))[m
[31m-  runParser expr2 "1-2*3/4+5*6-7-8/9" @?= Success (toStream "" 17) (BinOp Div (BinOp Minus (BinOp Minus (BinOp Mult (BinOp Plus (BinOp Div (BinOp Mult (BinOp Minus (Num 1) (Num 2)) (Num 3)) (Num 4)) (Num 5)) (Num 6)) (Num 7)) (Num 8)) (Num 9))[m
[32m+[m[32m  runParser expr2 "1+2*3-4/5" @?= Success (toStream "" (Position 0 9)) (BinOp Div (BinOp Minus (BinOp Mult (BinOp Plus (Num 1) (Num 2)) (Num 3)) (Num 4)) (Num 5))[m
[32m+[m[32m  runParser expr2 "1+2+3" @?= Success (toStream "" (Position 0 5)) (BinOp Plus (BinOp Plus (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m  runParser expr2 "1*2*3" @?= Success (toStream "" (Position 0 5)) (BinOp Mult (BinOp Mult (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m  runParser expr2 "1/2/3" @?= Success (toStream "" (Position 0 5)) (BinOp Div (BinOp Div (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m  runParser expr2 "1-2-3" @?= Success (toStream "" (Position 0 5)) (BinOp Minus (BinOp Minus (Num 1) (Num 2)) (Num 3))[m
[32m+[m[32m  runParser expr2 "1-2*3/4+5*6-7-8/9" @?= Success (toStream "" (Position 0 17)) (BinOp Div (BinOp Minus (BinOp Minus (BinOp Mult (BinOp Plus (BinOp Div (BinOp Mult (BinOp Minus (Num 1) (Num 2)) (Num 3)) (Num 4)) (Num 5)) (Num 6)) (Num 7)) (Num 8)) (Num 9))[m
[1mdiff --git a/test/Test/LLang.hs b/test/Test/LLang.hs[m
[1mindex 37f0aef..1c93ce2 100644[m
[1m--- a/test/Test/LLang.hs[m
[1m+++ b/test/Test/LLang.hs[m
[36m@@ -1,7 +1,9 @@[m
 module Test.LLang where[m
 [m
 import           AST[m
[31m-import           Combinators      (Parser (..), Result (..), runParser, toStream, symbol)[m
[32m+[m[32mimport           Combinators      (Parser (..), Result (..), runParser,[m
[32m+[m[32m                                   toStream, symbol, InputStream (..),[m
[32m+[m[32m                                   Position (..), ErrorMsg (..))[m
 import qualified Data.Map         as Map[m
 import           Data.Map            (empty, fromList)[m
 import           Debug.Trace      (trace)[m
[36m@@ -20,7 +22,9 @@[m [misFailure  _          = False[m
 [m
 checkParses :: (Eq r, Show r) => Parser String String r -> String -> r -> Assertion[m
 checkParses parser prog last = do[m
[31m-    runParser parser prog @?= Success (toStream "" (length prog)) last[m
[32m+[m[32m    case runParser parser prog of[m
[32m+[m[32m       Success (InputStream "" _) _ -> 1    @?= 1[m
[32m+[m[32m       otherwise                    -> prog @?= "IS NOT PARSING!"[m
 [m
 [m
 unit_parseAssign :: Assertion[m
[36m@@ -288,3 +292,54 @@[m [munit_parseProg = do[m
     assertBool "" $ isFailure $ runParser parseProg "Def f(x, y) { }; { Write (f(2)); }"[m
     assertBool "" $ isFailure $ runParser parseProg "Def f(x) { } Returns 0; { Write (f(2, 3)); }"[m
     assertBool "" $ isFailure $ runParser parseProg "{ Returns (2); }"[m
[32m+[m
[32m+[m
[32m+[m[32mcheckPos pos prog lasts = case runParser parseProg prog of[m
[32m+[m[32m      Success (InputStream lasts' pos') _ -> (pos', lasts') @?= (pos, lasts)[m
[32m+[m[32m      otherwise                          -> prog @?= "IS NOT PASRING!"[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32munit_progPosition :: Assertion[m
[32m+[m[32munit_progPosition = do[m
[32m+[m[32m    checkPos (Position 4 0) "{\n\tRead n;\n\tWrite(n);\n}\n" ""[m
[32m+[m[32m    checkPos (Position 2 4) "{\n\tRead n;}\n\tüëå" "üëå"[m
[32m+[m[32m    checkPos (Position 3 0) "{}\n\n\n" ""[m
[32m+[m[32m    checkPos (Position 2 9) "{}\n\n\t \t" ""[m
[32m+[m
[32m+[m
[32m+[m[32munit_errors :: Assertion[m
[32m+[m[32munit_errors = do[m
[32m+[m[32m    case runParser parseStatement "" of[m
[32m+[m[32m      Success _ _  -> "–ì–¥–µ —è " @?= "–±–ª–∏–Ω"[m
[32m+[m[32m      Failure msgs -> msgs @?= [ErrorMsg [[m
[32m+[m[32m         "Expected \"Assign\"",[m
[32m+[m[32m         "Expected \"Read\"",[m
[32m+[m[32m         "Expected \"Write\"",[m
[32m+[m[32m         "Expected \"{\"",[m
[32m+[m[32m         "Expected \"If\"",[m
[32m+[m[32m         "Expected \"While\""[m
[32m+[m[32m        ] (Position 0 0)][m
[32m+[m[32m    case runParser parseStatement "{\n\tR\n}\n" of[m
[32m+[m[32m      Success _ _  -> "–ì–¥–µ —è " @?= "–±–ª–∏–Ω"[m
[32m+[m[32m      Failure msgs -> msgs @?= [ErrorMsg [[m
[32m+[m[32m         "Expected \"Assign\"",[m
[32m+[m[32m         "Expected \"Read\"",[m
[32m+[m[32m         "Expected \"Write\"",[m
[32m+[m[32m         "Expected \"If\"",[m
[32m+[m[32m         "Expected \"While\""[m
[32m+[m[32m        ] (Position 0 0), ErrorMsg[[m
[32m+[m[32m         "Expected \"}\""[m
[32m+[m[32m        ] (Position 1 4)][m
[32m+[m[32m    case runParser parseStatement "\n \n  \tRead" of[m
[32m+[m[32m      Success _ _  -> "–ì–¥–µ —è " @?= "–±–ª–∏–Ω"[m
[32m+[m[32m      Failure msgs -> msgs @?= [ErrorMsg [[m
[32m+[m[32m         "Expected \"Assign\"",[m
[32m+[m[32m         "Expected \"Write\"",[m
[32m+[m[32m         "Expected \"{\"",[m
[32m+[m[32m         "Expected \"If\"",[m
[32m+[m[32m         "Expected \"While\""[m
[32m+[m[32m        ] (Position 2 6), ErrorMsg[[m
[32m+[m[32m         "Expected identifier",[m
[32m+[m[32m         "Predicate failed",[m
[32m+[m[32m         "Expected symbol: \'_\'"[m
[32m+[m[32m        ] (Position 2 10)][m
